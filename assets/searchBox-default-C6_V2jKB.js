const t='{"documentCount":9,"nextId":9,"documentIds":{"0":"/article/rk3ujhm2/#设计模式的诞生与发展","1":"/article/rk3ujhm2/#模式的诞生与定义","2":"/article/rk3ujhm2/#设计模式的定义与分类","3":"/article/rk3ujhm2/#设计模式的定义","4":"/article/rk3ujhm2/#设计模式的分类","5":"/article/rk3ujhm2/#gof-设计模式简介","6":"/article/rk3ujhm2/#gof-的-23-种模式一览表","7":"/article/rk3ujhm2/#gof-的-23-种设计模式的简要说明","8":"/article/rk3ujhm2/#设计模式的优点"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,2,63],"2":[1,2,1],"3":[1,3,64],"4":[1,3,12],"5":[2,1,1],"6":[4,3,33],"7":[4,3,123],"8":[1,1,15]},"averageFieldLength":[1.7777777777777777,2.111111111111111,34.77777777777778],"storedFields":{"0":{"title":"设计模式的诞生与发展","titles":[null]},"1":{"title":"模式的诞生与定义","titles":[null,"设计模式的诞生与发展"]},"2":{"title":"设计模式的定义与分类","titles":[null,"设计模式的诞生与发展"]},"3":{"title":"设计模式的定义","titles":[null,"设计模式的诞生与发展","设计模式的定义与分类"]},"4":{"title":"设计模式的分类","titles":[null,"设计模式的诞生与发展","设计模式的定义与分类"]},"5":{"title":"GoF 设计模式简介","titles":[null]},"6":{"title":"GoF 的 23 种模式一览表","titles":[null,"GoF 设计模式简介"]},"7":{"title":"GoF 的 23 种设计模式的简要说明","titles":[null,"GoF 设计模式简介"]},"8":{"title":"设计模式的优点","titles":[null]}},"dirtCount":0,"index":[["另一方面还可以提高软件的设计水平和代码质量",{"2":{"8":1}}],["一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码",{"2":{"8":1}}],["且易于修改",{"2":{"8":1}}],["方便地复用成功的设计和体系结构",{"2":{"8":1}}],["它提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流",{"2":{"8":1}}],["它包含了设计中存在的问题以及问题存在的原因",{"2":{"3":1}}],["表示一个作用与某对象结构中的各个元素的操作",{"2":{"7":1}}],["visitor",{"2":{"7":1}}],["vlissides",{"2":{"1":1}}],["允许一个对象在其内部状态改变时改变它的行为",{"2":{"7":1}}],["从而使其耦合松散",{"2":{"7":1}}],["从而可用不同的请求对客户进行参数化",{"2":{"7":1}}],["memento",{"2":{"7":1}}],["mediator",{"2":{"7":1}}],["method",{"2":{"7":2}}],["提供一种方法顺序访问一个聚合对象中的各个元素",{"2":{"7":1}}],["提供一个创建一系列相关或相互依赖对象的接口",{"2":{"7":1}}],["定义一系列算法",{"2":{"7":1}}],["定义一个操作中算法的框架",{"2":{"7":1}}],["定义一个对象来封装一系列对象的交互",{"2":{"7":1}}],["定义一个用于创建对象的接口",{"2":{"7":1}}],["定义对象直接按的一种一对多依赖关系",{"2":{"7":1}}],["定义它的文法的一种表示",{"2":{"7":1}}],["给定一个语言",{"2":{"7":1}}],["给某一个对象提供一个代理或占位符",{"2":{"7":1}}],["直到有一个对象能够处理它为止",{"2":{"7":1}}],["让多个对象都有机会处理请求",{"2":{"7":1}}],["让代码更容易被他人理解并且提高代码的可靠性",{"2":{"3":1}}],["避免将一个请求的发送者与接收者耦合在一起",{"2":{"7":1}}],["运用共享技术有效地支持大量细粒度对象的复用",{"2":{"7":1}}],["这样可以将对象恢复到原先保存的状态",{"2":{"7":1}}],["这个解释器使用该表示来解释语言中的句子",{"2":{"7":1}}],["这个接口使得这一子系统更加容易使用",{"2":{"7":1}}],["这标志着软件模式的诞生",{"2":{"1":1}}],["为子系统中的一组接口提供一个统一的入口",{"2":{"7":1}}],["就扩展功能而言",{"2":{"7":1}}],["动态地给一个对象增加一些额外的职责",{"2":{"7":1}}],["decorator",{"2":{"7":1}}],["descriptions",{"2":{"3":1}}],["design",{"2":{"3":3}}],["整体关系的层次结构",{"2":{"7":1}}],["组合多个对象形成树形结构以表示具有部分",{"2":{"7":1}}],["组合模式让客户端可以统一对待单个对象和组合对象",{"2":{"7":1}}],["组合模式",{"2":{"6":1,"7":1}}],["并以一种标准的形式供广大开发人员所用",{"2":{"8":1}}],["并让它们可以相互替换",{"2":{"7":1}}],["并在该对象之外保存这个状态",{"2":{"7":1}}],["并给定一个解释器",{"2":{"7":1}}],["并且在一定程度上节约设计成本",{"2":{"8":1}}],["并且沿着这条链传递请求",{"2":{"7":1}}],["并且通过复制这个原型来后创建新的对象",{"2":{"7":1}}],["并由代理对象来控制对原对象的访问",{"2":{"7":1}}],["并提供一个全局访问点来访问这个唯一实例",{"2":{"7":1}}],["确保一个类只有一个实例",{"2":{"7":1}}],["但是让子类决定将哪一个类实例化",{"2":{"7":1}}],["使得设计方案更加通俗易懂",{"2":{"8":1}}],["使得每当一个对象状态发生改变时其相关依赖对象皆得到通知被自动更新",{"2":{"7":1}}],["使得两者都能够独立变化",{"2":{"7":1}}],["使得同样得构建过程可以创建不同的表示",{"2":{"7":1}}],["使用原型实例指定待创建对象的类型",{"2":{"7":1}}],["使用抽象描述和怎样用一个具有一般意义的元素组合",{"2":{"3":1}}],["使用设计模式是为了可重用代码",{"2":{"3":1}}],["将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路",{"2":{"8":1}}],["将每一个算法封装起来",{"2":{"7":1}}],["将接收请求的对象连接成一条链",{"2":{"7":1}}],["将抽象部分与它的实例部分解耦",{"2":{"7":1}}],["将一个请求封装为一个对象",{"2":{"7":1}}],["将一个类的接口转换成客户希望的另一个接口",{"2":{"7":1}}],["将一个复杂对象的构建与它的表示分离",{"2":{"7":1}}],["将模式的概念引入软件工程领域",{"2":{"1":1}}],["bridge",{"2":{"7":1}}],["builder",{"2":{"7":1}}],["behavioral",{"2":{"4":1,"7":1}}],["而将一些步骤延迟到子类中",{"2":{"7":1}}],["而且可以独立地改变它们之间的交互",{"2":{"7":1}}],["而且会的到解决问题的最佳办法",{"2":{"1":1}}],["而又不用暴露该对象的内部表示",{"2":{"7":1}}],["而无需指定它们具体的类",{"2":{"7":1}}],["flyweight",{"2":{"7":1}}],["façade",{"2":{"7":1}}],["factory",{"2":{"7":2}}],["four",{"2":{"1":1}}],["种设计模式的简要说明",{"0":{"7":1}}],["种模式一览表",{"0":{"6":1}}],["访问者模式可以在不改变各元素的类的前提下定义作用于这些元素的新操作",{"2":{"7":1}}],["访问者模式",{"2":{"6":1,"7":1}}],["策略模式让算法可以独立于使用它的客户而变化",{"2":{"7":1}}],["策略模式",{"2":{"6":1,"7":1}}],["状态模式",{"2":{"6":1,"7":1}}],["观察者模式",{"2":{"6":1,"7":1}}],["备忘录模式",{"2":{"6":1,"7":1}}],["中介者模式使各对象之间不需要显示地相互引用",{"2":{"7":1}}],["中介者模式",{"2":{"6":1,"7":1}}],["迭代器模式",{"2":{"6":1,"7":1}}],["命令模式",{"2":{"6":1,"7":1}}],["职责链模式",{"2":{"6":1,"7":1}}],["代理模式",{"2":{"6":1,"7":1}}],["代码设计经验的总结",{"2":{"3":1}}],["享元模式",{"2":{"6":1,"7":1}}],["外观模式定义了一个高层接口",{"2":{"7":1}}],["外观模式",{"2":{"6":1,"7":1}}],["装饰模式提供一种比使用子类更加灵活的替代方案",{"2":{"7":1}}],["装饰模式",{"2":{"6":1,"7":1}}],["桥接模式",{"2":{"6":1,"7":1}}],["单例模式",{"2":{"6":1,"7":1}}],["原型模式",{"2":{"6":1,"7":1}}],["建造者模式",{"2":{"6":1,"7":1}}],["抽象工厂模式",{"2":{"6":1,"7":1}}],["对请求排队或者记录请求日志",{"2":{"7":1}}],["对象看起来似乎修改了它的类",{"2":{"7":1}}],["对象",{"2":{"6":1}}],["对象模式",{"2":{"6":1}}],["对设计模式的定义如下",{"2":{"3":1}}],["模板方式模式",{"2":{"7":1}}],["模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤",{"2":{"7":1}}],["模板方法模式",{"2":{"6":1}}],["模式说明",{"2":{"7":1}}],["模式类别",{"2":{"7":1}}],["模式名称",{"2":{"3":1,"7":1}}],["模式是一种直到",{"2":{"1":1}}],["模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案",{"2":{"1":1}}],["模式之父",{"2":{"1":1}}],["模式",{"2":{"1":1}}],["模式的诞生与定义",{"0":{"1":1}}],["适配器模式让那些接口不兼容的类可以一起工作",{"2":{"7":1}}],["适配器模式",{"2":{"6":2,"7":1}}],["工厂方法模式让一个类的实例化延迟到其子类",{"2":{"7":1}}],["工厂方法模式",{"2":{"6":1,"7":1}}],["类",{"2":{"6":1}}],["类模式",{"2":{"6":1}}],["类或对象组合",{"2":{"3":1}}],["行为型模式",{"2":{"6":1,"7":1}}],["创建型模式",{"2":{"6":1,"7":1}}],["范围",{"2":{"6":1}}],["23",{"0":{"6":1,"7":1}}],["的",{"0":{"6":1,"7":1}}],["根据范围分类",{"2":{"4":1}}],["根据目的分类",{"2":{"4":1}}],["三类",{"2":{"4":1}}],["结构型模式",{"2":{"6":1,"7":1}}],["结构型",{"2":{"4":1}}],["结局方案描述了设计模式的组成成分",{"2":{"3":1}}],["没有一个解决方案是百分之百完美的",{"2":{"3":1}}],["来解决这个问题",{"2":{"3":1}}],["不针对具体问题",{"2":{"3":1}}],["各自的职责和协作方式",{"2":{"3":1}}],["以及支持可撤销的操作",{"2":{"7":1}}],["以及这些组成成分的相互关系",{"2":{"3":1}}],["以便更好地理解模式并方便开发人员之间的交流",{"2":{"3":1}}],["在不破坏封装的前提下捕获一个对象的内部状态",{"2":{"7":1}}],["在使用设计模式时需要进行合理的评价和选择",{"2":{"3":1}}],["在对问题进行描述的同时实际上就确定了模式所对应的使用环境以及模式的使用动机",{"2":{"3":1}}],["在一个良好的指导下有助于设计一个优良的解决方案",{"2":{"1":1}}],["绝大多数模式都是根据其功能或模式结构来命名的",{"2":{"3":1}}],["通过一两个词来描述模式的问题",{"2":{"3":1}}],["name",{"2":{"3":1}}],["个",{"2":{"3":1}}],["个部分构成",{"2":{"1":1}}],["其中的关键元素有以下",{"2":{"3":1}}],["实例代码和相关设计模式",{"2":{"3":1}}],["效果描述了模式应用的效果以及在使用模式时应权衡的问题",{"2":{"3":1}}],["效果",{"2":{"3":2}}],["解释器模式",{"2":{"6":1,"7":1}}],["解决方案和效果",{"2":{"3":1}}],["解决方案",{"2":{"3":2}}],["解法和效果",{"2":{"1":1}}],["目的",{"2":{"3":1,"6":1}}],["问题描述了应该在何时使用模式",{"2":{"3":1}}],["问题",{"2":{"3":2}}],["iterator",{"2":{"7":1}}],["interpreter",{"2":{"7":1}}],["in",{"2":{"3":1}}],["is",{"2":{"1":1}}],["template",{"2":{"7":1}}],["that",{"2":{"3":1}}],["to",{"2":{"1":1,"3":1}}],["该方案描述了对象和类之间的相互作用",{"2":{"3":1}}],["经过分类编目的",{"2":{"3":1}}],["多数人知晓的",{"2":{"3":1}}],["是一套被反复使用的",{"2":{"3":1}}],["设计模式有助于初学者更深入地理解面向对象思想",{"2":{"8":1}}],["设计模式使得设计方案更加灵活",{"2":{"8":1}}],["设计模式使人们可以更加简单",{"2":{"8":1}}],["设计模式融合了众多专家的经验",{"2":{"8":1}}],["设计模式简介",{"0":{"5":1},"1":{"6":1,"7":1}}],["设计模式一般有两种分类方式",{"2":{"4":1}}],["设计模式一般包含模式名称",{"2":{"3":1}}],["设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定值的解决方案",{"2":{"3":1}}],["设计模式",{"2":{"3":1}}],["设计模式的使用将提高软件系统的开发效率和软件质量",{"2":{"8":1}}],["设计模式的优点",{"0":{"8":1}}],["设计模式的分类",{"0":{"4":1}}],["设计模式的定义",{"0":{"3":1}}],["设计模式的定义与分类",{"0":{"2":1},"1":{"3":1,"4":1}}],["设计模式的诞生与发展",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1}}],["如下图所示",{"2":{"1":1}}],["环境或约束条件",{"2":{"1":1}}],["前提条件",{"2":{"1":1}}],["即问题描述",{"2":{"1":1}}],["软件模式的基本结构由",{"2":{"1":1}}],["软件模式是在一定条件下的软件开发问题及其解法",{"2":{"1":1}}],["软件模式并非仅仅限于设计模式",{"2":{"1":1}}],["分为类模式和对象模式两种",{"2":{"4":1}}],["分为创建型",{"2":{"4":1}}],["分析模式和过程模式等",{"2":{"1":1}}],["分别是",{"2":{"1":1}}],["还包括架构模式",{"2":{"1":1}}],["位著名软件工程学者",{"2":{"1":1}}],["4",{"2":{"1":2,"3":1}}],["自称的",{"2":{"1":1}}],["john",{"2":{"1":1}}],["johnson",{"2":{"1":1}}],["和行为型",{"2":{"4":1}}],["和",{"2":{"1":1}}],["helm",{"2":{"1":1}}],["responsibility",{"2":{"7":1}}],["recurring",{"2":{"1":1}}],["ralph",{"2":{"1":1}}],["richard",{"2":{"1":1}}],["erich",{"2":{"1":1}}],["efficient",{"2":{"1":1}}],["general",{"2":{"3":1}}],["gamma",{"2":{"1":1}}],["gang",{"2":{"1":1}}],["gof",{"0":{"5":1,"6":1,"7":1},"1":{"6":1,"7":1},"2":{"1":2,"3":1}}],["observer",{"2":{"7":1}}],["objects",{"2":{"3":1}}],["of",{"2":{"1":1,"3":1,"7":1}}],["or",{"2":{"1":1}}],["四人组",{"2":{"1":1}}],["年以",{"2":{"1":1}}],["1992",{"2":{"1":1}}],["1991",{"2":{"1":1}}],["最早将模式的思想引入软件工程学的是",{"2":{"1":1}}],["达到事半功倍的效果",{"2":{"1":1}}],["当一个领域逐渐成熟的时候自然会有很多模式",{"2":{"1":1}}],["chain",{"2":{"7":1}}],["christopher",{"2":{"1":1}}],["creational",{"2":{"4":1,"7":1}}],["customized",{"2":{"3":1}}],["classes",{"2":{"3":1}}],["command",{"2":{"7":1}}],["communicating",{"2":{"3":1}}],["composite",{"2":{"7":1}}],["consequences",{"2":{"3":1}}],["context",{"2":{"1":1,"3":1}}],["within",{"2":{"1":1}}],["proxy",{"2":{"7":1}}],["prototype",{"2":{"7":1}}],["problem",{"2":{"1":1,"3":2}}],["particular",{"2":{"3":1}}],["patterns",{"2":{"3":1,"7":3}}],["pattern",{"2":{"1":2,"3":2,"7":23}}],["strategy",{"2":{"7":1}}],["structural",{"2":{"4":1,"7":1}}],["state",{"2":{"7":1}}],["singleton",{"2":{"7":1}}],["solve",{"2":{"3":1}}],["solution",{"2":{"1":1,"3":1}}],["successful",{"2":{"1":1}}],["adapter",{"2":{"7":1}}],["abstract",{"2":{"7":1}}],["and",{"2":{"3":1}}],["are",{"2":{"3":2}}],["a",{"2":{"1":4,"3":2}}],["alexander",{"2":{"1":1}}],["博士",{"2":{"1":1}}],["起源于建筑业而非软件业",{"2":{"1":1}}]],"serializationVersion":2}';export{t as default};
